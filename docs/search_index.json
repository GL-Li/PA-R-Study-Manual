[
["r-programming.html", "Chapter 3 R Programming 3.1 Notebook Chunks 3.2 Basic operations 3.3 Lists 3.4 Functions 3.5 Data Frames 3.6 Pipes", " Chapter 3 R Programming There are already many great R tutorials available. To save time, this book will cover the absolute essentials. The book “R for Data Science” provides one such introduction. https://r4ds.had.co.nz/ 3.1 Notebook Chunks On the Exam, you will start with an .Rmd (R Markdown) template. The way that this book writes code is in the R Notebook. Learning markdown is useful for other web development and documentation tasks as well. Code is organized into chunks. To run everything in a chunk quickly, press CTRL + SHIFT + ENTER. To create a new chunk, use CTRL + ALT + I. 3.2 Basic operations The usual math operations apply. #addition 1 + 2 ## [1] 3 3 - 2 ## [1] 1 #multiplication 2*2 ## [1] 4 #division 4/2 ## [1] 2 #exponentiation 2^3 ## [1] 8 There are two assignment operators: “=” and “&lt;-”. The latter is preferred because it is specific to assigning a variable to a value. The “=” operator is also used for assigning values in functions (see the functions section). In R, the shortchut ALT + - creates a “&lt;-”. #variable assignment x = 2 y &lt;- 2 #equality 4 == 2 #False ## [1] FALSE 5 == 5 #true ## [1] TRUE 3.14 &gt; 3 #true ## [1] TRUE 3.14 &gt;= 3 #true ## [1] TRUE Vectors can be added just like numbers. The “c” stands for “concatenate”, which creates vectors. x &lt;- c(1,2) y &lt;- c(3,4) x + y ## [1] 4 6 x*y ## [1] 3 8 z &lt;- x + y z^2 ## [1] 16 36 z/2 ## [1] 2 3 z + 3 ## [1] 7 9 Lists are like vectors but can take any type of object type. I already mentioned numeric types. There are also character (string) types, factor types, and boolean types. character &lt;- &quot;The&quot; character_vector &lt;- c(&quot;The&quot;, &quot;Quick&quot;) Factors are characters that expect only specific values. A charater can take on any value. A factor is only allowed a finite number of values. This reduces the memory size. The below factor has only one “level”, which is the list of assigned values. factor = as.factor(character) levels(factor) ## [1] &quot;The&quot; The levels of a factor are by default in R in alphabetical order (Q comes alphabetically before T). factor_vector &lt;- as.factor(character_vector) levels(factor_vector) ## [1] &quot;Quick&quot; &quot;The&quot; Booleans are just True and False values. R understands “T” or “TRUE” in the same way. When doing math, bools are converted to 0/1 values where 1 is equivalent to TRUE and 0 FALSE. bool_true &lt;- T bool_false &lt;- F bool_true*bool_false ## [1] 0 Vectors work in the same way. bool_vect &lt;- c(T,T, F) sum(bool_vect) ## [1] 2 3.3 Lists Lists are vectors that can hold mixed object types. Vectors need to be all of the same type. ls &lt;- list(T, &quot;Character&quot;, 3.14) ls ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] &quot;Character&quot; ## ## [[3]] ## [1] 3.14 Lists can be named. ls &lt;- list(bool = T, character = &quot;character&quot;, numeric = 3.14) ls ## $bool ## [1] TRUE ## ## $character ## [1] &quot;character&quot; ## ## $numeric ## [1] 3.14 The “$” operator indexes lists. ls$numeric ## [1] 3.14 ls$numeric + 5 ## [1] 8.14 Lists can contain vectors, other lists, and any other object. everything &lt;- list(vector = c(1,2,3), character = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), list = ls) everything ## $vector ## [1] 1 2 3 ## ## $character ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $list ## $list$bool ## [1] TRUE ## ## $list$character ## [1] &quot;character&quot; ## ## $list$numeric ## [1] 3.14 To find out the type of an object, use class or str or summary. class(x) ## [1] &quot;numeric&quot; class(everything) ## [1] &quot;list&quot; str(everything) ## List of 3 ## $ vector : num [1:3] 1 2 3 ## $ character: chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## $ list :List of 3 ## ..$ bool : logi TRUE ## ..$ character: chr &quot;character&quot; ## ..$ numeric : num 3.14 summary(everything) ## Length Class Mode ## vector 3 -none- numeric ## character 3 -none- character ## list 3 -none- list 3.4 Functions You only need to understand the very basics of functions for this exam. Still, understanding functions helps you to understand everything in R, since R is a functional programming language, unlike Python, C, VBA, Java which are all Object-oriented, or SQL which isn’t really a language but a series of set-operations. Functions do things. The convention is to name a function as a verb. The function make_rainbows() would create a rainbow. The function summarise_vectors would summarise vectors. Functions may or may not have an input and output. If you need to do something in R, there is a high probability that someone has already written a function to do it. That being said, creating simple functions is quite useful. A function that does not return anything greet_me &lt;- function(my_name){ print(paste0(&quot;Hello, &quot;, my_name)) } greet_me(&quot;Future Actuary&quot;) ## [1] &quot;Hello, Future Actuary&quot; A function that returns something When returning something, the return statement is optional. add_together &lt;- function(x, y){ x + y } add_together(2,5) ## [1] 7 add_together &lt;- function(x, y){ return(x + y) } add_together(2,5) ## [1] 7 Functions can work with vectors. x_vector &lt;- c(1,2,3) y_vector &lt;- c(4,5,6) add_together(x_vector, y_vector) ## [1] 5 7 9 3.5 Data Frames R is an old programming language. The original data.frame object has been updated with the newer and better tibble (like the word “table”). Tibbles are really lists of vectors, where each column is a vector. library(tibble) #the tibble library has functions for making tibbles data &lt;- tibble(age = c(25, 35), has_fsa = c(F, T)) data ## # A tibble: 2 x 2 ## age has_fsa ## &lt;dbl&gt; &lt;lgl&gt; ## 1 25 FALSE ## 2 35 TRUE To index columns in a tibble, the same “$” is used as indexing a list. data$age ## [1] 25 35 To find the number of rows and columns, use dim. dim(data) ## [1] 2 2 To fine a summary, use summary summary(data) ## age has_fsa ## Min. :25.0 Mode :logical ## 1st Qu.:27.5 FALSE:1 ## Median :30.0 TRUE :1 ## Mean :30.0 ## 3rd Qu.:32.5 ## Max. :35.0 3.6 Pipes The pipe operator “%&gt;%” is a way of making code more readible and easier to edit. The way that we are taught to do functional composition is by nesting, which is slow to read and write. In five seconds, tell me what the below code is doing. log(sqrt(exp(log2(sqrt((max(c(3, 4, 16)))))))) ## [1] 1 Did you get the answer of 1? If so, you are good at reading paremthasis. This requires starting from the inner-most nested brackets and moving outwards from right to left. The math notation would be slightly easier to read, but still painful. \\[log(\\sqrt{e^{log_2(\\sqrt{max(3,4,16)})}})\\] Here is the same algebra using the pipe. To read this, replace the “%&gt;%” with the word “THEN”. library(dplyr) #the pipe is from the dplyr library ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union max(c(3, 4, 16)) %&gt;% sqrt() %&gt;% log2() %&gt;% exp() %&gt;% sqrt() %&gt;% log() ## [1] 1 #max(c(3, 4, 16) THEN #The max of 3, 4, and 16 is 16 # sqrt() THEN #The square root of 16 is 4 # log2() THEN #The log in base 2 of 4 is 2 # exp() THEN #the exponent of 2 is e^2 # sqrt() THEN #the square root of e^2 is e # log() #the natural logarithm of e is 1 You may not be convinced by this simple example using numbers; however, once we get to data manipulations in the next section the advantage of piping will become obvious. To quickly produce pipes, use CTRL + SHIFT + M. By highlighting only certain sections, we can run the code in steps as if we were using a debugger. This makes testing out code much faster. max(c(3, 4, 16)) ## [1] 16 max(c(3, 4, 16)) %&gt;% sqrt() ## [1] 4 max(c(3, 4, 16)) %&gt;% sqrt() %&gt;% log2() ## [1] 2 max(c(3, 4, 16)) %&gt;% sqrt() %&gt;% log2() %&gt;% exp() ## [1] 7.389056 max(c(3, 4, 16)) %&gt;% sqrt() %&gt;% log2() %&gt;% exp() %&gt;% sqrt() ## [1] 2.718282 max(c(3, 4, 16)) %&gt;% sqrt() %&gt;% log2() %&gt;% exp() %&gt;% sqrt() %&gt;% log() ## [1] 1 Those familiar with Python’s Pandas will be see that “%&gt;%” is quite similar to “.”. "]
]
