ggplot(dat,aes(x=Rd_Character,y=log(Crash_Score),fill=Rd_Class))+
geom_boxplot()+
facet_wrap(~Rd_Character,scale="free")
# ---- CODE MODIFIED ----
# Visual exploration of interaction. Try pairs that seem intuitively likely to have an interaction. This example uses Rd_Feature and Rd_Class, but they were selected at random.
ggplot(dat,aes(x=Traffic_Control,y=log(Crash_Score),fill=Rd_Feature))+
geom_boxplot()+
facet_wrap(~Traffic_Control,scale="free")
# ---- ADDITIONAL CODE CREATED ----
dat$Month <- as.factor(dat$Month)
levels(dat$Month)
# ---- CODE PROVIDED TO CANDIDATES ----
#Create train and test sets
library(caret)
set.seed(1234)
partition <- createDataPartition(dat$Crash_Score, list = FALSE, p = .75)
train <- dat[partition, ]
test <- dat[-partition, ]
print("TRAIN")
mean(train$Crash_Score)
print("TEST")
mean(test$Crash_Score)
# ---- CODE PROVIDED TO CANDIDATES ----
#OLS on current variables
GLMols <- glm(Crash_Score ~ ., family = gaussian(), data = train)
summary(GLMols)
print("AIC")
AIC(GLMols)
predict <- predict(GLMols,newdata=test,type="response")
print("RMSE")
sqrt(sum((test$Crash_Score-predict)^2)/nrow(test))
# ---- CODE PROVIDED TO CANDIDATES ----
#OLS on current variables
GLM <- glm(Crash_Score ~ ., family = gaussian(), data = train)
summary(GLM)
print("AIC")
AIC(GLM)
predict <- predict(GLM,newdata=test,type="response")
print("RMSE")
sqrt(sum((test$Crash_Score-predict)^2)/nrow(test))
# ---- CODE PROVIDED TO CANDIDATES ----
#OLS on current variables
GLM <- glm(Crash_Score ~ ., family = gaussian(), data = train)
print("AIC")
AIC(GLM)
predict <- predict(GLM,newdata=test,type="response")
print("RMSE")
sqrt(sum((test$Crash_Score-predict)^2)/nrow(test))
GLM <- glm(Crash_Score ~ ., family = gaussian(link = "log"), data = train)
print("AIC")
AIC(GLM)
predict <- predict(GLM,newdata=test,type="response")
print("RMSE")
sqrt(sum((test$Crash_Score-predict)^2)/nrow(test))
GLM <- glm(Crash_Score ~ ., family = gamma(link = "log"), data = train)
GLM <- glm(Crash_Score ~ ., family = gamma(link = "log"), data = train)
GLM <- glm(Crash_Score ~ ., family = Gamma(link = "log"), data = train)
print("AIC")
AIC(GLM)
predict <- predict(GLM,newdata=test,type="response")
print("RMSE")
sqrt(sum((test$Crash_Score-predict)^2)/nrow(test))
?AIC
# ---- MODIFIED CODE ----
library(MASS)
GLMgamma1 <- glm(Crash_Score ~ 1, family = Gamma(link = "log"), data = train)
#Sets up the null model for use with forward selection. The full model was obtained in Task 5.
stepAIC(GLMgamma1, direction = "forward", k = log(nrow(train)), scope = list(upper = GLMgamma, lower = GLMgamma1))
# ---- MODIFIED CODE ----
library(MASS)
GLMgamma1 <- glm(Crash_Score ~ 1, family = Gamma(link = "log"), data = train)
#Sets up the null model for use with forward selection. The full model was obtained in Task 5.
stepAIC(GLMgamma1, direction = "forward", k = log(nrow(train)), scope = list(upper = GLM, lower = GLMgamma1))
?stepAIC
#Sets up the null model for use with forward selection. The full model was obtained in Task 5.
stepAIC(GLMgamma1, direction = "backward", k = log(nrow(train)), scope = list(upper = GLM, lower = GLMgamma1))
#Sets up the null model for use with forward selection. The full model was obtained in Task 5.
stepAIC(GLMgamma1, direction = "forward", k = log(nrow(train)), scope = list(upper = GLM, lower = GLMgamma1))
# ---- ADDITIONAL CODE CREATED ----
#Gamma/log model on reduced variables
GLMgammaR <- glm(Crash_Score ~ Rd_Class + Rd_Feature + Time_of_Day + Traffic_Control, family = Gamma(link = "log"), data = train)
summary(GLMgammaR)
print("AIC")
AIC(GLMgammaR)
predict <- predict(GLMgammaR,newdata=test,type="response")
print("RMSE")
sqrt(sum((test$Crash_Score-predict)^2)/nrow(test))
# ---- ADDITIONAL CODE CREATED ----
plot(GLMgammaR)
# ---- ADDITIONAL CODE CREATED ----
#Gamma model on reduced variables with full dataset
GLMgammaRdat <- glm(Crash_Score ~ Rd_Class + Rd_Feature + Time_of_Day + Traffic_Control, family = Gamma(link = "log"), data = dat)
summary(GLMgammaRdat)
plot(model, which = 1)
df <- tibble(y = rgamma(100, 0, 1))
df %>% qplot(y)
df
?rgamma
df <- tibble(y = rgamma(100,shape = 1))
df
df %>% qplot()
df %>% qplot(y)
df %>% ggplot(aes(y)) + geom_histogram()
df <- tibble(y = rgamma(1000,shape = 1))
df %>% ggplot(aes(y)) + geom_histogram()
df %>% mutate(x1 = y + rnorm(1000, 0, 1),
x2 = y + rnorm(1000, 10, 2))
df <- df %>% mutate(x1 = y + rnorm(1000, 0, 1),
x2 = y + rnorm(1000, 10, 2))
glm <- glm(y ~ x1 + x2,
family = Gamma(link = "log"),
data = df)
plot(glm)
summary(glm)
df %>% ggplot(aes(y)) + geom_histogram()
glm <- glm(y ~ x1 + x2,
family = Gamma(link = "identity"),
data = df)
glm <- glm(y ~ x1 + x2,
family = Gamma,
data = df)
?Gamma
glm <- glm(y ~ x1 + x2,
family = Gamma(link = "identity"),
data = df)
plot(glm)
data = df)
#simulate a gamma random variable
df <- tibble(y = rgamma(1000,shape = 1))
df %>% ggplot(aes(y)) + geom_histogram()
#create two predictor variables which have a white noise term
df <- df %>% mutate(x1 = y + rnorm(1000, 0, 1),
x2 = y + rnorm(1000, 10, 2))
#fit a GLM
glm <- glm(y ~ x1 + x2,
family = Gamma(link = "log"),
data = df)
plot(glm)
summary(glm)
#simulate a gamma random variable
df <- tibble(y = rgamma(1000,shape = 1))
library(tidyverse)
#simulate a gamma random variable
df <- tibble(y = rgamma(1000,shape = 1))
df %>% ggplot(aes(y)) + geom_histogram()
set.seed(15)
#create two predictor variables which have a white noise term
df <- df %>% mutate(x1 = y + 0.1*rnorm(1000, 0, 1) + 10,
x2 = y + 0.1*rnorm(1000, 10, 2) + 10)
#fit a GLM
glm <- glm(y ~ x1 + x2,
family = Gamma(link = "log"),
data = df)
plot(glm, which = 2)
summary(glm)
residual(glm, type = "deviance")
library(stats)
residual(glm, type = "deviance")
residuals(glm, type = "deviance")
residuals <- residuals(glm, type = "deviance")
hist(residuals)
df <- df %>% mutate(residuals = residuals(glm, type = "deviance"))
df %>% ggplot(aes(residuals))
df %>% ggplot(aes(residuals)) + geom_histogram()
library(devtools)
install_github("sdcastillo/ExamPAData")
library(tidyverse)
library(ExamPAData)
# Loading data & releveling factors
dat <- june_pa %>%
mutate_if(is.character, fct_infreq)
# Boxplots split by level of each variable.
library(ggplot2)
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=as.factor(dat[[i]]),y=Crash_Score)) + geom_boxplot() + labs(x=i)
print(plot)
}
#Means and medians of the target variable split by predictor.
library(dplyr)
for (i in vars) {
print(i)
x <- dat %>% group_by_(i)%>%summarise(mean=mean(Crash_Score),
median=median(Crash_Score),
n = n())
print(x)
}
# Bar charts of predictor variables
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=dat[i])) + geom_bar() + labs(x=i) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
print(plot)
}
# Bar charts of predictor variables
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=dat[[i]])) + geom_bar() + labs(x=i) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
print(plot)
}
#This example combines levels other than SIGNAL of Traffic_Control into a new level called NON-SIGNAL.
#Execute the function levels(dat$Traffic_Control) to idenity the levels. Be sure the variable is a factor variable before doing this.
dat2<-dat #The results are in a new data frame called dat2. This is done so that the results can be checked without losing the original data frame. When done, consider executing dat <- dat2 so subsequent chunks can run without modification
library(plyr)
var <- "Traffic_Control"
var.levels <- levels(dat2[,var])
dat2[,var] <- mapvalues(dat2[[var]],var.levels,c("NON-SIGNAL","NON-SIGNAL","SIGNAL","NON-SIGNAL","NON-SIGNAL"))
#This example combines levels other than SIGNAL of Traffic_Control into a new level called NON-SIGNAL.
#Execute the function levels(dat$Traffic_Control) to idenity the levels. Be sure the variable is a factor variable before doing this.
dat2<-dat #The results are in a new data frame called dat2. This is done so that the results can be checked without losing the original data frame. When done, consider executing dat <- dat2 so subsequent chunks can run without modification
library(plyr)
var <- "Traffic_Control"
var.levels <- levels(dat2[,var])
dat2[[var]] <- mapvalues(dat2[[var]],var.levels,c("NON-SIGNAL","NON-SIGNAL","SIGNAL","NON-SIGNAL","NON-SIGNAL"))
#Retain only the variables used for PCA and Binarize them
datPCA <- dat %>% select(Rd_Conditions, Light, Weather)
library(caret)
# dummyVars is not compatible with factors
varsPCA <- colnames(datPCA)
for (var in varsPCA) {
datPCA[[var]] <- as.character(datPCA[[var]])
}
# Binarize variables
#fullRank = FALSE implies that all values get coded. This is appropriate for PCA (but not for regression)
binarizer <- caret::dummyVars(paste("~", paste(varsPCA, collapse = "+")) , data = datPCA, fullRank = FALSE)
datPCAbin <- data.frame(predict(binarizer, newdata = datPCA))
head(datPCAbin)
#Run PCA on the weather variables. Variables are centered and scaled.
PCAweather <- prcomp(datPCAbin, center = TRUE, scale. = TRUE)
summary(PCAweather)
PCAweather$rotation
#Center and scale the variables
datPCAbin.std <- as.data.frame(scale(datPCAbin))
#Create a new feature
dat2 <- dat #Preserving the original data frame until this work is complete
dat2$Snow.not.rain <- 0.5*datPCAbin.std$Rd_ConditionsICE.SNOW.SLUSH + .6*datPCAbin.std$WeatherSNOW - .2*datPCAbin.std$WeatherRAIN
head(dat2$Snow.not.rain)
# Visual exploration of interaction. Try pairs that seem intuitively likely to have an interaction. This example uses Rd_Feature and Rd_Class, but they were selected at random.
ggplot(dat,aes(x=Rd_Feature,y=Crash_Score,fill=Rd_Class))+
geom_boxplot()+
facet_wrap(~Rd_Feature,scale="free")
#Create train and test sets
library(caret)
set.seed(1234)
partition <- createDataPartition(dat$Crash_Score, list = FALSE, p = .75)
train <- dat[partition, ]
test <- dat[-partition, ]
print("TRAIN")
mean(train$Crash_Score)
print("TEST")
mean(test$Crash_Score)
#OLS on current variables
GLMols <- glm(Crash_Score ~ ., family = gaussian(), data = train)
summary(GLMols)
print("AIC")
AIC(GLMols)
predict <- predict(GLMols,newdata=test,type="response")
print("RMSE")
sqrt(sum((test$Crash_Score-predict)^2)/nrow(test))
library(MASS)
GLMols1 <- glm(Crash_Score ~ 1, family = gaussian(), data = train) #If using forward selection it is necessary to fit a model with no predictors to use as the start.
stepAIC(GLMols1, direction = "forward", k = log(nrow(train)), scope = list(upper = GLMols, lower = GLMols1)) #For backward selection, the first argument should be GLMols, the full model.
library(MASS)
GLMols1 <- glm(Crash_Score ~ 1, family = gaussian(), data = train) #If using forward selection it is necessary to fit a model with no predictors to use as the start.
stepAIC(GLMols1, direction = "backward", k = log(nrow(train)), scope = list(upper = GLMols, lower = GLMols1)) #For backward selection, the first argument should be GLMols, the full model.
stepAIC(GLMols1, direction = "backward", k = log(nrow(train)), scope = list(upper = GLMols, lower = GLMols1)) #For backward selection, the first argument should be GLMols, the full model.
library(MASS)
GLMols1 <- glm(Crash_Score ~ 1, family = gaussian(), data = train) #If using forward selection it is necessary to fit a model with no predictors to use as the start.
stepAIC(GLMols1, direction = "backward", k = log(nrow(train)), scope = list(upper = GLMols, lower = GLMols1)) #For backward selection, the first argument should be GLMols, the full model.
library(MASS)
GLMols1 <- glm(Crash_Score ~ 1, family = gaussian(), data = train) #If using forward selection it is necessary to fit a model with no predictors to use as the start.
stepAIC(GLMols1, direction = "forward", k = log(nrow(train)), scope = list(upper = GLMols, lower = GLMols1)) #For backward selection, the first argument should be GLMols, the full model.
?stepAIC
stepAIC(GLMols1, direction = "forward", k = 2, scope = list(upper = GLMols, lower = GLMols1)) #For backward selection, the first argument should be GLMols, the full model.
library(glmnet)
set.seed(42)
X <- model.matrix(Crash_Score ~ .,train)
m <- cv.glmnet(x = X,
y = train$Crash_Score,
family = "gaussian",
alpha = 1) #alpha = 1 implies LASSO, alpha = 0 implies ridge
plot(m)
library(tidyverse)
library(ExamPAData)
# Loading data & releveling factors
dat <- june_pa %>%
mutate_if(is.character, fct_infreq)
dat %>% glimpse()
dat %>% ggplot(aes(Crash_Score)) + geom_histogram()
dat$Crash_Score %>% summary()
# Boxplots split by level of each variable.
library(ggplot2)
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=as.factor(dat[[i]]),y=Crash_Score)) + geom_boxplot() + labs(x=i)
print(plot)
}
# Boxplots split by level of each variable.
library(ggplot2)
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=as.factor(dat[[i]]),y=log(Crash_Score))) + geom_boxplot() + labs(x=i)
print(plot)
}
for (i in vars) {
plot <- ggplot(dat, aes(x=as.factor(dat[[i]]),y=log(Crash_Score))) + geom_boxplot() + labs(x=i) + coord_flip()
print(plot)
}
#Means and medians of the target variable split by predictor.
library(dplyr)
for (i in vars) {
print(i)
x <- dat %>% group_by_(i)%>%summarise(mean=mean(Crash_Score),
median=median(Crash_Score),
n = n())
print(x)
}
#Means and medians of the target variable split by predictor.
library(dplyr)
print(i)
x <- dat %>% group_by_(i)%>%summarise(mean=mean(Crash_Score),
median=median(Crash_Score),
n = n())
dat %>% map_dbl(~mean)
dat %>% map_dbl(mean)
dat %>% map_dbl(mean)
dat %>% map_dbl(median)
dat %>% map_dbl(~median(.x, na.rm = T))
dat %>% glimpse()
for (i in vars) {
print(i)
x <- dat %>% group_by_(i)%>% summarise(mean=mean(Crash_Score),
median=median(Crash_Score),
n = n())
print(x)
}
for (i in vars) {
print(i)
x <- dat %>% group_by_(i)%>% summarise(mean=mean(Crash_Score),
median=median(Crash_Score))
print(x)
}
for (i in vars) {
print(i)
x <- dat %>% group_by_(i)%>% summarise(mean=mean(Crash_Score),
median=median(Crash_Score))
print(x)
}
dat %>% glimpse()
dat %>%
group_by(year) %>%
summarise(mean = mean(Crash_Score),
median = median(Crash_Score))
dat %>%
group_by(year) %>%
dplyr::summarise(mean = mean(Crash_Score),
median = median(Crash_Score))
x <- dat %>% group_by_(i)%>% dplyr::summarise(mean=mean(Crash_Score),
median=median(Crash_Score))
for (i in vars) {
print(i)
x <- dat %>% group_by_(i)%>% dplyr::summarise(mean=mean(Crash_Score),
median=median(Crash_Score))
print(x)
}
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=dat[[i]])) + geom_bar() + labs(x=i) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
print(plot)
}
dat %>%
mutate(Time_of_Day = case_when(
Time_of_Day == 1 ~ "Early Morning",
Time_of_Day == 1 ~ "Early Morning",
Time_of_Day == 1 ~ "Early Morning",
Time_of_Day == 1 ~ "Early Morning",
))
Time_of_Day == 1 ~ "Early Morning",```
dat %>%
mutate(Time_of_Day = case_when(
Time_of_Day == 1 ~ "Morning",
Time_of_Day == 2 ~ "Morning",
Time_of_Day == 3 ~ "Day",
Time_of_Day == 4 ~ "Day",
Time_of_Day == 5 ~ "Evening",
Time_of_Day == 6 ~ "Night"
)) %>%
count(Time_of_Day)
library(dplyr)
dat %>%
mutate(Time_of_Day = case_when(
Time_of_Day == 1 ~ "Morning",
Time_of_Day == 2 ~ "Morning",
Time_of_Day == 3 ~ "Day",
Time_of_Day == 4 ~ "Day",
Time_of_Day == 5 ~ "Evening",
Time_of_Day == 6 ~ "Night"
)) %>%
count(Time_of_Day)
dat %>%
dplyr::mutate(Time_of_Day = case_when(
Time_of_Day == 1 ~ "Morning",
Time_of_Day == 2 ~ "Morning",
Time_of_Day == 3 ~ "Day",
Time_of_Day == 4 ~ "Day",
Time_of_Day == 5 ~ "Evening",
Time_of_Day == 6 ~ "Night"
)) %>%
count(Time_of_Day)
dat %>%
dplyr::mutate(Time_of_Day = case_when(
Time_of_Day == 1 ~ "Morning",
Time_of_Day == 2 ~ "Morning",
Time_of_Day == 3 ~ "Day",
Time_of_Day == 4 ~ "Day",
Time_of_Day == 5 ~ "Evening",
Time_of_Day == 6 ~ "Night"
))
dat %>%
dplyr::mutate(Time_of_Day = case_when(
Time_of_Day == 1 ~ "Morning",
Time_of_Day == 2 ~ "Morning",
Time_of_Day == 3 ~ "Day",
Time_of_Day == 4 ~ "Day",
Time_of_Day == 5 ~ "Evening",
Time_of_Day == 6 ~ "Night"
)) %>%
count(Time_of_Day)
detach("stats")
rm(list = ls())
lapply(paste('package:',names(sessionInfo()$otherPkgs),sep=""),detach,character.only=TRUE,unload=TRUE)
# Loading data
library(ExamPAData)
dat <- june_pa %>%
mutate_if(is.character, fct_infreq)
library(tidyverse)
dat <- june_pa %>%
mutate_if(is.character, fct_infreq)
library(ggplot2)
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=as.factor(dat[[i]]),y=Crash_Score)) + geom_boxplot() + labs(x=i)
print(plot)
}
#Means and medians of the target variable split by predictor.
library(dplyr)
for (i in vars) {
print(i)
x <- dat %>% group_by_(i)%>%summarise(mean=mean(Crash_Score),
median=median(Crash_Score),
n = n())
print(x)
}
# Bar charts of predictor variables
vars <- colnames(dat)[colnames(dat)!="Crash_Score"]
for (i in vars) {
plot <- ggplot(dat, aes(x=dat[[i]])) + geom_bar() + labs(x=i) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
print(plot)
}
#This example combines levels other than SIGNAL of Traffic_Control into a new level called NON-SIGNAL.
#Execute the function levels(dat$Traffic_Control) to idenity the levels. Be sure the variable is a factor variable before doing this.
dat2<-dat #The results are in a new data frame called dat2. This is done so that the results can be checked without losing the original data frame. When done, consider executing dat <- dat2 so subsequent chunks can run without modification
library(plyr)
var <- "Traffic_Control"
var.levels <- levels(dat2[[var]])
dat2[[var]] <- mapvalues(dat2[[var]],var.levels,c("NON-SIGNAL","NON-SIGNAL","SIGNAL","NON-SIGNAL","NON-SIGNAL"))
#Relevel
table <- as.data.frame(table(dat2[[var]]))
max <- which.max(table[,2])
level.name <- as.character(table[max,1])
dat2[var] <- relevel(dat2[[var]], ref = level.name)
table(dat2[[var]])
#Retain only the variables used for PCA and Binarize them
datPCA <- dat[c("Rd_Conditions", "Light", "Weather")]
library(caret)
# dummyVars is not compatible with factors
varsPCA <- colnames(datPCA)
for (var in varsPCA) {
datPCA[[var]] <- as.character(datPCA[[var]])
}
# Binarize variables
#fullRank = FALSE implies that all values get coded. This is appropriate for PCA (but not for regression)
binarizer <- caret::dummyVars(paste("~", paste(varsPCA, collapse = "+")) , data = datPCA, fullRank = FALSE)
datPCAbin <- data.frame(predict(binarizer, newdata = datPCA))
head(datPCAbin)
#Run PCA on the weather variables. Variables are centered and scaled.
PCAweather <- prcomp(datPCAbin, center = TRUE, scale. = TRUE)
summary(PCAweather)
PCAweather$rotation
#Center and scale the variables
datPCAbin.std <- as.data.frame(scale(datPCAbin))
#Create a new feature
dat2 <- dat #Preserving the original data frame until this work is complete
dat2$Snow.not.rain <- 0.5*datPCAbin.std$Rd_ConditionsICE.SNOW.SLUSH + .6*datPCAbin.std$WeatherSNOW - .2*datPCAbin.std$WeatherRAIN
head(dat2$Snow.not.rain)
# Visual exploration of interaction. Try pairs that seem intuitively likely to have an interaction. This example uses Rd_Feature and Rd_Class, but they were selected at random.
ggplot(dat,aes(x=Rd_Feature,y=Crash_Score,fill=Rd_Class))+
geom_boxplot()+
facet_wrap(~Rd_Feature,scale="free")
library(plyr)
var <- "Traffic_Control"
var.levels <- levels(dat2[[var]])
dat2[[var]] <- mapvalues(dat2[[var]],var.levels,c("NON-SIGNAL","NON-SIGNAL","SIGNAL","NON-SIGNAL","NON-SIGNAL"))
#Relevel
table <- as.data.frame(table(dat2[[var]]))
max <- which.max(table[,2])
level.name <- as.character(table[max,1])
dat2[var] <- relevel(dat2[[var]], ref = level.name)
rm(list = ls())
library(plyr)
var <- "Traffic_Control"
var.levels <- levels(dat2[[var]])
lapply(paste('package:',names(sessionInfo()$otherPkgs),sep=""),detach,character.only=TRUE,unload=TRUE)
