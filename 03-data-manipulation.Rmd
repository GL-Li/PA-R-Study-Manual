# Data manipulation

```{r warning = F, echo = F, message = F}
library(plyr)
library(dplyr)
library(ggplot2)
library(caret)

#set figure size
knitr::opts_chunk$set(fig.width=6, fig.height=4) 

#This is an optional library to add emojis to rmd files
# install.packages("devtools")
#devtools::install_github("hadley/emo")
library(emo)

library(ExamPAData)
library(tidyverse)#always load AFTER plyr.  Otherwise there are errors because some functions have the same names in both libraries.

library(kableExtra)
format_table <- function(data){data %>% kableExtra::kable("html") %>% kable_styling(bootstrap_options = "striped", full_width = F)}
```

Exam PA will have questions about the data.  That is a fact.  Every version of Exam PA such as December 2018, June 2019, and December 2019 have all had questions about data manipulation.  Putting in extra practice in this area is garanteed to give you a better score because it will free up time that you can use elsewhere.  

This lesson is based on the first task of the 2019 Exam PA.

**TASK 1 (12 points)**

> Examine each variable and make appropriate adjustments.

> Examine each predictor variable other than cap_gain both on its own and with respect to value_flag.  Make appropriate adjustments.  Do not make any adjustments to the cap_gain variable at this time.

>There should be no further variable adjustments unless specifically requested.

All data for this book can be accessed from the package `ExamPAData`.  In the real exam, you will read the file from the Prometric computer.

Because the data is already loaded, simply use the below code to access the data.

```{r}
library(ExamPAData)
```

To save keystrokes, give the data a short name such as `df` for "data frame".

```{r}
df <- customer_value %>% mutate_if(is.character, as.factor)
```

## Garbage in; garbage out `r emo::ji("trash")`

This is a common saying when working with predictive models.  No matter how complex the model, if the data is bad then the entire result will be bad.  For this exam, master the art of data manipulation and everything becomes easier!

Begin by looking at a summary.

```{r}
summary(df)
str(df)
```

## Be a detective `r emo::ji("magnifying")`

Sherlock Holmes is famous for saying "You see, Watson, but you do not observe!"

Just like detectives, actuaries need to collect data and make observations.  Each exam has a few "anomalies" in the data which they expect candidates to mention.  These could be

* Any value that doesn't match the Data Dictionary in the Project Statement
* Variables that have `NA` values
* Variables that have a lot of factor levels
* Incorrect data types
    * Factors that are read as characters or vice versa
    * Numeric variables that are factor/character
* Extreme values (Numeric values are too high or low)

You'll get very good at spotting these with practice.  Just from looking at the above `summary`, we can observe the following:

**Observations**

* The data consists of 48,842 obs. of 8 variables.
* The lowest `age` is 17 but the Project Statement says to only include records with `age` >= 25.
* The `age` distribution is right skewed because the median (37) is less than the mean (38).
* `education_num` takes integer values between 1 and 16.  There are a lot of values that are low.
* There are missing values when `occupation` is `group NA`, which means that the person's occupationw as unknown.
* The amount that people work per work, `hours_per_week`, varies by a lot.  The lowest is 1 hour and the highest is 99.  Most people work 40 hours per week.

The SOA's solution recommends leaving comments in your Rmd file.  This helps to give you partial credit on questions that you may answer incorrectly.  

**Good comments**

```{r}
#I observe that there are no missing values other than those indicated by Group NA for occupation.

#I removed the code provided by my assistant. It is embedded in later chunks as needed.

#I excluded people under the age of 25
df <- df[df$age >= 25,]

#I convert the target to 0-1.
df$value_flag <- ifelse(df$value_flag == "High",1,0)
```

**Useless comments**

```{r}
#this is a comment

#this loads a library called ggplot2
library(ggplot2)
```

## A picture is worth a thousand words `r emo::ji("camera")`

What's your favorite type of graph?  Mine is a radar chart  This is a graphical method of displaying multivariate data in the form of a two-dimensional chart of three or more quantitative variables represented on axes staring from the same point.

Isn't this pretty?

```{r echo = F, message = F, warning = f}
# Library
library(fmsb)
 
# Create data: note in High school for Jonathan:
data <- as.data.frame(matrix( sample( 2:20 , 10 , replace=T) , ncol=10))
colnames(data) <- c("math" , "english" , "biology" , "music" , "R-coding", "data-viz" , "french" , "physic", "statistic", "sport" )
 
# To use the fmsb package, I have to add 2 lines to the dataframe: the max and min of each topic to show on the plot!
data <- rbind(rep(20,10) , rep(0,10) , data)
 
# Check your data, it has to look like this!
# head(data)

# The default radar chart 
radarchart(data)
```

**Don't waste time trying to make the graphs perfect!**

Only change code that you **need** to change.  The SOA is trying to help you save time by giving you templates.  That being said, if you can do it faster on your own, then do it your own way.

This is the code template that they give you.  You only need to change the "variable" names.

```{r eval = F}
# This code makes a histogram for a continuous variable.
ggplot(df, aes(x = variable)) + 
  geom_histogram(bins = 30) +
  labs(x = "variable") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# This code makes a bar chart for a factor variable.
ggplot(df, aes(x = variable)) +
  geom_bar() +
  labs(x = "variable") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

Okay, that wasn't 100% true.  It's common for the code to require **small** changes. For instance, the histogram that they give you has bins that are too narrow for`age`, which causes these spikes to show up in the graph.

> The best candidates altered the code to create more appropriate plots and summary tables.

```{r message = F}
# This code makes a histogram for a continuous variable.
ggplot(df, aes(x = age)) + 
  geom_histogram(bins = 30) + #not the right number of bins
  labs(x = "age") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  ggtitle("Bad: Default histogram with spikes")

#Histograms of continuous variables
ggplot(df, aes(x = age)) +
  geom_histogram(breaks = seq(24.5,99.5, by = 5)) +  #make bins wider and set range 
  labs(x = "Age") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  ggtitle("Good: After adjusting the breaks")
```

How do you know when a variable should a factor and when it should be numeric?

## Factor or numeric `r emo::ji("question")`

Which variables should be converted to factors and which should be numeric? 

Questions of this sort have come up twice.  On Hospital Readmissions, there was a Length of Stay variable that was numeric, but had only a few values and so some candidates treated it as a factor.  The `education_num` variable here is also numeric but only has 16 unique values.  So should this be a numeric or a factor?

```{r}
table(df$education_num)
```

Ask yourself this question: is there a way of comparing two values of the variable together?

* If yes, then use numeric  
* If no, then use a factor

For exmaple, we can say that `education_num = 2` is less than `education_num = 4`, which means that there's a natural order.  This is also known as an **ordinal**.

If the factor is say, `color`, which can be `red`, `blue`, or `green`, then there is no way of comparing values together.  Is `red` greater than `blue`?  This question has no meaning.


```{r}
ggplot(df, aes(x = education_num)) +
  geom_histogram(bins = 30) +
  labs(x = "Education") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  ggtitle("Default number of bins (30)")

ggplot(df, aes(x = education_num)) +
  geom_histogram(bins = 16) +
  labs(x = "Education") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  ggtitle("Set number of bins to number of factor levels (16) ")
# Set bins equal to number of levels, could have made bar chart.
```

We could also use a bar plot.

```{r}
ggplot(df, aes(x = education_num)) + 
  geom_bar(stat = "count") + 
  ggtitle("Bar plot")
```

Lastly, read the Project Statement carefully and only do what it tells you to do.

> Candidates were not required to make a plot for cap_gain. This solution has the plot made here rather than in Task 6.

## 73.6% of statistics are false `r emo::ji("shocked")`

Really?  No, but statistics can help you see patterns that data visualization by itself can miss.  Along with the ggplot codes, there will be code to look at summary statistics.  Here's a refresher on what these statistics mean (no pun intended).

* **Mean**: The average. This gets skewed by outliers easily.  If the mean greater than the median, then the distribution is right skewed. 
* **Median**: The "middle" value.  This is an average that reduces the impact of outliers.
* **Variance**: Amount by which each observation differs from the mean.  
* **Standard Deviation**: Square root of the variance.
* **n()**: Number of observations. Always take note of groups that don't have many observations.

```{r eval =F}
# This code provides, for each level of a factor variable, the number for which value_flag is zero, the number for which it is one, the total number of observations, and the proportion of ones.
# Note that the variable name should not be enclosed in quotation marks.
df %>%
  group_by(variable) %>%
  summarise(
    zeros = sum(value_flag == 0),
    ones = sum(value_flag == 1),
    n = n(),
    proportion = mean(value_flag)
  )
```

Factors levels should be simplified.  If a group has only a few observations then there will be problems with the model.  In our data, take a look at the `marital_status` column.  Do you observe anything unusual?

```{r}
table(df$marital_status)
```

Only 31 records have `Married-AF-spouse`.  This is because the sample size `n = 31` is too small.  In modeling jargon, this is "statistical insignificant" and will cause the p-value on `marital_status` to be large.  You can fix this in a few different ways

* Delete these records (Not recommended)
* Group these records together with `Married-spouse` (Simplest method)

Let's use the second method.

First, look at the levels of the factor variable.

```{r}
levels(df$marital_status)
```

Now look at the profitability across marital status.  For `Married-AF-spouse` and `Married-civ-spouse` the proportion of high profit customers is **high**, but for `Married-spouse-absent` it is **low.**  Even though these are all "married", it would be a bad idea to combine them because the profitability is so different.

```{r}
#Proportion of ones by category of factor variable
df %>%
  group_by(marital_status) %>%
  summarise(
    zeros = sum(value_flag == 0),
    ones = sum(value_flag == 1),
    n = n(),
    proportion = mean(value_flag)
  )
```


Then create a vector that has the simpler levels that you want.  The order needs to be the same.

```{r}
simple_levels <- c("Divorced", "Married-spouse", "Married-spouse", "Married-spuouse-absent", "Neber-married", "Separated", "Widowed")
```

The SOA likes to use the function `mapvalues`.  This takes in three arguments.  You can read about this by typing `?mapvalues` into the console.

`x`	: the factor or vector to modify

`from` : a vector of the items to replace

`to`	: a vector of replacement values

Then map the old values to the simpler values.

```{r}
#Combine the two marital status levels
var.levels <- levels(df$marital_status)
df$marital_status <- mapvalues(x = df$marital_status,
                               from = var.levels, 
                               to = simple_levels) 
```

Now, when you look at the `marital_status` levels, you will see the simpler levels.  

```{r}
levels(df$marital_status)
```

You can also check that the number of records is what you expect.

```{r}
table(df$marital_status)
```

There's an automatic way of doing this as well.  And everyone likes to automate things because it gives us more free time `r emo::ji("sleep")`.

Create dummy variables for each category and then use a variable selection method to decide which levels to keep.  This could be from a LASSO, a GLM with Step AIC/BIC, or any tree-based method.

## How to save time with dplyr

You may have noticed that writing code for data manipulation can be slow.  Fortunately, there is a faster, 100%-legal, way of doing data manipulation that has worked for hundreds of exam candidates (the author included) who have taken Exam PA.  

Up to this point we have been using old R libraries.  By making use of newer R libraries we can save ourselves time.  These will all be provided for you at Prometric within the (tidyverse)[https://www.tidyverse.org/] library.


Suggested reading of *R for Data Science* (https://r4ds.had.co.nz/index.html):


| Chapter | Topic           |
|---------|-----------------|
| 9       | Introduction    |
| 10      | Tibbles         |
| 12      | Tidy data       |
| 15      | Factors         |
| 17      | Introduction    |
| 18      | Pipes           |
| 19      | Functions       |
| 20      | Vectors         |


## Look at the data

The data that we are using is `health_insurance`, which has information on patients and their health care costs.

The descriptions of the columns are below.  

- `age`: Age of the individual
- `sex`: Sex
- `bmi`: Body Mass Index
- `children`: Number of children
- `smoker`: Is this person a smoker?
- `region`: Region
- `charges`: Annual health care costs.

`head()` shows the top n rows.  `head(20)` shows the top 20 rows.  

```{r message = F}
library(tidyverse)
head(health_insurance)
```

Using a pipe is an alternative way of doing this. 

```{r eval = F}
health_insurance %>% head()
```

>**Shortcut**: Use `CTRL` + `SHFT` + `M` to create pipes `%>%`

The `glimpse` function is a transpose of the `head()` function, which can be more spatially efficient.  This also gives you the dimension (1,338 rows, 7 columns).

```{r}
health_insurance %>% glimpse()
```

One of the most useful data science tools is counting things.  The function `count()` gives the number of records by a categorical feature.   

```{r}
health_insurance %>% count(children)
```

Two categories can be counted at once.  This creates a table with all combinations of `region` and `sex` and shows the number of records in each category.

```{r}
health_insurance %>% count(region, sex)
```

The `summary()` function is shows a statistical summary.  One caveat is that each column needs to be in it's appropriate type.  For example, `smoker`, `region`, and `sex` are all listed as characters when if they were factors, `summary` would give you count info.

**With incorrect data types**

```{r}
health_insurance %>% summary()
```

**With correct data types**

This tells you that there are 324 patients in the northeast, 325 in the northwest, 364 in the southeast, and so fourth.

```{r}
health_insurance <- health_insurance %>% 
  modify_if(is.character, as.factor)

health_insurance %>% 
  summary()
```

## Transform the data

Transforming, manipulating, querying, and wrangling are synonyms in data terminology.

R syntax is designed to be similar to SQL.  They begin with a `SELECT`, use `GROUP BY` to aggregate, and have a `WHERE` to remove records.  Unlike SQL, the ordering of these does not matter.  `SELECT` can come after a `WHERE`.

**R to SQL translation**

```
select() -> SELECT
mutate() -> user-defined columns
summarize() -> aggregated columns
left_join() -> LEFT JOIN
filter() -> WHERE
group_by() -> GROUP BY
filter() -> HAVING
arrange() -> ORDER BY

```

```{r}
health_insurance %>% 
  select(age, region) %>% 
  head()
```

Tip: use `CTRL + SHIFT + M` to create pipes `%>%`.

Let's look at only those in the southeast region.  Instead of `WHERE`, use `filter`.

```{r}
health_insurance %>% 
  filter(region == "southeast") %>% 
  select(age, region) %>% 
  head()
```

The SQL translation is

```{sql eval = F}
SELECT age, region
FROM health_insurance
WHERE region = 'southeast'
```


Instead of `ORDER BY`, use `arrange`.  Unlike SQL, the order does not matter and `ORDER BY` doesn't need to be last.

```{r}
health_insurance %>% 
  arrange(age) %>% 
  select(age, region) %>% 
  head()
```

The `group_by` comes before the aggregation, unlike in SQL where the `GROUP BY` comes last.

```{r}
health_insurance %>% 
  group_by(region) %>% 
  summarise(avg_age = mean(age))
```

In SQL, this would be

```{sql eval = F}
SELECT region, 
       AVG(age) as avg_age
FROM health_insurance
GROUP BY region
```


Just like in SQL, many different aggregate functions can be used such as `SUM`, `MEAN`, `MIN`, `MAX`, and so forth.

```{r}
health_insurance %>% 
  group_by(region) %>% 
  summarise(avg_age = mean(age),
            max_age = max(age),
            median_charges = median(charges),
            bmi_std_dev = sd(bmi))
```

To create new columns, the `mutate` function is used.  For example, if we wanted a column of the person's annual charges divided by their age

```{r}
health_insurance %>% 
  mutate(charges_over_age = charges/age) %>% 
  select(age, charges, charges_over_age) %>% 
  head(5)
```

We can create as many new columns as we want.

```{r}
health_insurance %>% 
  mutate(age_squared  = age^2,
         age_cubed = age^3,
         age_fourth = age^4) %>% 
  head(5)
```

The `CASE WHEN` function is quite similar to SQL.  For example, we can create a column which is `0` when `age < 50`, `1` when `50 <= age <= 70`, and `2` when `age > 70`.

```{r}
health_insurance %>% 
  mutate(age_bucket = case_when(age < 50 ~ 0,
                                age <= 70 ~ 1,
                                age > 70 ~ 2)) %>% 
  select(age, age_bucket)
```

SQL translation:

```{sql eval = F}
SELECT CASE WHEN AGE < 50 THEN 0
       ELSE WHEN AGE <= 70 THEN 1
       ELSE 2
FROM health_insurance
```

## Exercises

Run this code on your computer to answer these exercises.

The data `actuary_salaries` contains the salaries of actuaries collected from the DW Simpson survey.  Use this data to answer the exercises below.

```{r }
actuary_salaries %>% glimpse()
```

1.  How many industries are represented?
2.  The `salary_high` column is a character type when it should be numeric.  Change this column to numeric.
3.  What are the highest and lowest salaries for an actuary in Health with 5 exams passed?
4.  Create a new column called `salary_mid` which has the middle of the `salary_low` and `salary_high` columns.
5.  When grouping by industry, what is the highest `salary_mid`?  What about `salary_high`?  What is the lowest `salary_low`?
6.  There is a mistake when `salary_low == 11`.  Find and fix this mistake, and then rerun the code from the previous task.
7.  Create a new column, called `n_exams`, which is an integer.  Use 7 for ASA/ACAS and 10 for FSA/FCAS.  Use the code below as a starting point and fill in the `_` spaces
8. Create a column called `social_life`, which is equal to `n_exams`/`experience`.  What is the average (mean) `social_life` by industry?  Bonus question: what is wrong with using this as a statistical measure?


```{r eval = F, echo = T}
actuary_salaries <- actuary_salaries %>% 
  mutate(n_exams = case_when(exams == "FSA" ~ _,
                             exams == "ASA" ~ _,
                             exams == "FCAS" ~ _,
                             exams == "ACAS" ~ _,
                             TRUE ~ as.numeric(substr(exams,_,_)))) 
```

8. Create a column called `social_life`, which is equal to `n_exams`/`experience`.  What is the average (mean) `social_life` by industry?  Bonus question: what is wrong with using this as a statistical measure?


## Answers to exercises

Answers to these exercises, along with a video tutorial, are available at [ExamPA.net](https://www.exampa.net/pricing).
